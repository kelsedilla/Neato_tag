<!DOCTYPE html>
<html>
  <head>
    <title>Milestone 2</title>
    <link rel="stylesheet" href="css/style.css">
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Milestone 2</h1>
      </header>
      
      <div class="content">
        <h2>Localization Subteam</h2>
        
        <h3>Goal</h3>
        <p>The localization subteam's goal this week was to run the AMCL particle filter on a map we created.</p>
        
        <h3>Creating a Map - Improvements</h3>
        <p>We created a map using ROS's SLAM toolbox. We did this last milestone, but this one is nicer and doesn't have any loop closure issues.</p>
        
        <div class="image-container">
          <img src="images/map-milestone2.png" alt="Generated map outside of MAC 206">
          <p class="image-caption">The generated map (outside of MAC 206). This map has only a few small holes and no loop closure issues.</p>
        </div>
        
        <h3>Particle Filter</h3>
        <p>We ran the particle filter from ROS's AMCL package using the map we created and successfully localized a Neato as it drives around the map.</p>
        
        <h3>Challenges</h3>
        <p>Multiple setup issues. Loading a map into rviz was challenging for the following reasons:</p>
        <ul>
          <li>After exporting, the map says (result=0), implying that the yaml file is broken with no way to fix it.
            <ul>
              <li>Fix: although (result=0) implies that the yaml file is broken, this output is completely fine.</li>
            </ul>
          </li>
          <li>The created map refused to load into Rviz
            <ul>
              <li>Fix: We used special configurations for the map to load: <span style="font-family:'Courier New'">rviz2 -d ~/ros2_ws/src/robot_localization/rviz/amcl.rviz</span></li>
            </ul>
          </li>
        </ul>
        
        <h3>Next Steps</h3>
        <p>Our next step is to implement the AMCL particle filter to two Neatos which both share the same map. This will require meeting with the Multi-Neato subteam to learn how to run programs that control two Neatos. We will then have to adapt their methods to run a separate particle filter for each of the two Neatos and publish both locations to rviz. After successfully tracking the positions of both Neatos through the particle filter, we can as a stretch goal for the next milestone work towards building the logic for the chasing Neato to tag the other Neato using the shared locations.</p>
      </div>
      <div class="content">
        <h2>Multi-Neato Subteam</h2>
        
        <h3>Goal</h3>
        <p>Going into milestone 2, our goals were to run our multi-Neato teleop code on two Neatos and to create a plan for the final project’s file structure, which will combine learnings from all three subteams.</p>
        
        <h3>Teleop</h3>
        <p>We spent some time tidying our ros2 directories before we were able to successfully build packages and run the code, but once we were able to run it, there were just a few small bugs to fix before it was working. </p>
        <p>Once the code was running successfully, we discussed progress with the other subteams and decided to make an improved teleop file, adapted from Brenna’s project 1 code, which would have more intuitive controls for each Neato.</p>

        <p>Writing the teleop files has given us good practice writing nodes that communicate to multiple Neatos. This will be very important for our final project, which will require communicating different instructions to the chaser Neato and the escaper Neato.</p>
        
        <h3>Project Structure</h3>
        <p>The diagram below shows our plan for the file setup and publishers of the final project.</p>
        
        <div class="image-container">
          <img src="image here" alt="Diagram of project structure with nodes and publishers">
        </div>
        <p>Both Neato1 and Neato2 have their own particle filter node since the locations of both on the world map are needed for the chase. Both particle filters send location data of their respective Neato to the chase_logic node which calculates what direction and speed is needed for Neato1 to follow Neato2, then sends those velocity instructions to Neato1. Neato2 gets its velocity instructions from teleop, so the user can play as Neato 2 in the game of tag.</p>

        <p>One important mystery of this set up is that we currently don’t know how to specify which Neato a particle filter is running on using ros2’s particle filter package. This will be a very important question to solve, as we will need to specify which particle filter is running on which neato.</p>
        
        <h3>Next Steps</h3>
        <p>Now that we have a plan for project structure, we will need to tag up with the whole team again and start writing and testing these files. We will also need to answer our question regarding multiple particle filters.</p>
        <p>We are planning how to integrate our existing work into the final project structure. Our chase_logic node can use the neato’s locations on the world map (from the particle filter) to send Neato1 in the approximate direction of Neato 2, and use machine vision tracking to narrow in on Neato2 and improve chasing accuracy. The localization subteam is currently learning Bash scripting to be able to create a script that can run all nodes with one command. The multi-Neato subteam will probably spend a good part of the next milestone figuring out our multiple particle filter question, and ironing out other wrinkles that come from using multiple neatos.</p>
      </div>
    </div>
  </body>
</html>
