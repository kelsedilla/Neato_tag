<!DOCTYPE html>
<html>
  <head>
    <title>Milestone 2</title>
    <link rel="stylesheet" href="style.css">
  </head>
  <body>
    <div class="container">
      <header>
        <h1>Milestone 2</h1>
      </header>
      
      <div class="content">
        <h2>Localization Subteam</h2>
        
        <h3>Goal</h3>
        <p>The localization subteam's goal this week was to run the AMCL particle filter on a map we created.</p>
        
        <h3>Creating a Map - Improvements</h3>
        <p>We created a map using ROS's SLAM toolbox. We did this last milestone, but this one is nicer and doesn't have any loop closure issues.</p>
        
        <div class="image-container">
          <img src="images/MAC306Map.png" alt="Generated map outside of MAC 306">
          <p class="image-caption">The generated map (outside of MAC 306). This map has only a few small holes and no double walls.</p>
        </div>
        
        <h3>Particle Filter</h3>
        <p>We ran the particle filter from ROS's AMCL package using the map we created and successfully localized a Neato as it drives around the map.</p>
        
        <div class="image-container">
          <img src="images/particle_filter.gif" alt="GIF of particle filter running.">
        </div>

        <h3>Challenges</h3>
        <p>Multiple setup issues. Loading a map into rviz was challenging for the following reasons:</p>
        <ul>
          <li>After exporting, the map says (result=0), implying that the yaml file is broken with no way to fix it.
            <ul>
              <li>Fix: although (result=0) implies that the yaml file is broken, this output is completely fine.</li>
            </ul>
          </li>
          <li>The created map refused to load into Rviz
            <ul>
              <li>Fix: We used special configurations for the map to load: <span style="font-family:'Courier New'">rviz2 -d ~/ros2_ws/src/robot_localization/rviz/amcl.rviz</span></li>
            </ul>
          </li>
        </ul>
        
        <h3>Next Steps</h3>
        <p>Our next step is to implement the AMCL particle filter to two Neatos which both share the same map. This will require meeting with the Multi-Neato subteam to learn how to run programs that control two Neatos. We will then have to adapt their methods to run a separate particle filter for each of the two Neatos and publish both locations to rviz. After successfully tracking the positions of both Neatos through the particle filter, we can as a stretch goal for the next milestone work towards building the logic for the chasing Neato to tag the other Neato using the shared locations.</p>
      </div>
      <div class="content">
        <h2>Multi-Neato Subteam</h2>
        
        <h3>Goal</h3>
        <p>Going into milestone 2, our goals were to run our multi-Neato teleop code on two Neatos and to create a plan for the final project’s file structure, which will combine learnings from all three subteams.</p>
        
        <h3>Teleop</h3>
        <p>We spent some time tidying our ros2 directories before we were able to successfully build packages and run the code, but once we were able to run it, there were just a few small bugs to fix before it was working. </p>
        <p>Once the code was running successfully, we discussed progress with the other subteams and decided to make an improved teleop file, adapted from Brenna’s project 1 code, which would have more intuitive controls for each Neato.</p>

        <p>Writing the teleop files has given us good practice writing nodes that communicate to multiple Neatos. This will be very important for our final project, which will require communicating different instructions to the chaser Neato and the escaper Neato.</p>
        
        <h3>Project Structure</h3>
        <p>The diagram below shows our plan for the file setup and publishers of the final project.</p>
        
        <div class="image-container">
          <img src="images/diagram1.jpg" alt="Diagram of project structure with nodes and publishers">
        </div>
        <p>Both Neato1 and Neato2 have their own particle filter node since the locations of both on the world map are needed for the chase. Both particle filters send location data of their respective Neato to the chase_logic node which calculates what direction and speed is needed for Neato1 to follow Neato2, then sends those velocity instructions to Neato1. Neato2 gets its velocity instructions from teleop, so the user can play as Neato 2 in the game of tag.</p>

        <p>One important mystery of this set up is that we currently don’t know how to specify which Neato a particle filter is running on using ros2’s particle filter package. This will be a very important question to solve, as we will need to specify which particle filter is running on which neato.</p>
        
        <h3>Next Steps</h3>
        <p>Now that we have a plan for project structure, we will need to tag up with the whole team again and start writing and testing these files. We will also need to answer our question regarding multiple particle filters.</p>
        <p>We are planning how to integrate our existing work into the final project structure. Our chase_logic node can use the neato’s locations on the world map (from the particle filter) to send Neato1 in the approximate direction of Neato 2, and use machine vision tracking to narrow in on Neato2 and improve chasing accuracy. The localization subteam is currently learning Bash scripting to be able to create a script that can run all nodes with one command. The multi-Neato subteam will probably spend a good part of the next milestone figuring out our multiple particle filter question, and ironing out other wrinkles that come from using multiple neatos.</p>
      </div>
      <div class="content">
        <h2>Machine Vision Subteam</h2>
        
        <h3>Goal</h3>
        <p>Our goal for milestone 2 was to complete our machine vision pipeline.</p>

        <h3>Machine Vision Pipeline</h3>
        <p>Our machine vision pipeline goal is to be able extract and return the bounding box of a specified color in an image, in our case neon pink.</p>
        <div class="image-container">
          <img src="images/color_detection.png" alt="Bounding box around neaon pink area">
        </div>
        <ul>
          <li><strong>Convert to HSV:</strong> Transform the input image from BGR to HSV for better object detection</li>
          <li><strong>Make Color Threshold:</strong> Convert the target color <code>RGB(221,101,121)</code> to HSV and define a small range around it for detection</li>
          <li><strong>Create a Color Mask:</strong> Use <code>cv2.inRange</code> to isolate pixels within the target pink range</li>
          <li><strong>Edge Detection:</strong> Apply Canny edge detection to highlight boundaries of the detected regions</li>
          <li><strong>Morphological Closing:</strong> Close small gaps in edges to improve contour stability</li>
          <li><strong>Find and Filter Contours:</strong> Extract contours and discard small noisy ones (area &lt; 50 pixels)</li>
          <li><strong>Merge Contours:</strong> Combine all detected contours into a single bounding rectangle</li>
          <li><strong>Return Bounding Box:</strong> Output the coordinates <code>[X1, Y1, X2, Y2]</code>, or <code>None</code> if nothing is detected</li>
       </ul>
       <h3>Machine Neato Tag Pipeline</h3>
       <p>After we finished our machine vision pipeline, we made our initial chaser robot logic. This does not yet have the bump sensor logic implemented.</p>
        <ul>
            <li><strong>Gets image:</strong> Subscribes to the camera topic (<code>camera/image_raw</code>) and stores the latest image in <code>self.cv_image</code>.</li>
            <li><strong>Color Detection:</strong> Runs <code>color_detection</code> on each image to find the neon-pink object and get a bounding box</li>
            <li><strong>Bounding Box Processing:</strong> 
                <ul>
                    <li>Computes the center of the bounding box</li>
                    <li>Converts the bounding box to approximate angles using <code>convert_to_lidar_angles</code></li>
                    <li>Determines the turn direction for the robot to face the target</li>
                </ul>
            </li>
            <li><strong>Send Velocity Commands to Neato</strong> 
                <ul>
                    <li>If the Neato is detected, the Neato moves forward and turns proportionally to the target angle</li>
                    <li>If not detected, the Neato slowly rotates in the last known turn direction to search for the other Neato</li>
                </ul>
            </li>
        </ul>
        <p>This pipeline loops over and over again to make the chaser Neato track and follow the chasee Neato</p>
        <h3>Next Steps</h3>
        <p>Our next steps are to add in the bump detection logic and run a full game of Neato tag with our autonomous chaser Neato and teleop-ed chasee Neato. We have also done some work on using the SORT algorithm and hope to implement that into our code. We may investigate some of our other stretch goals like creating an autonomous chasee Neato. This will require us to integrate with the other subteams and we plan to coordinate with them.</p>
      </div>
    </div>
  </body>
</html>
